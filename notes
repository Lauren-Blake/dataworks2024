# Notes to run proximity calculation with toy example

# Obtain toolbox
git clone https://github.com/emreg00/toolbox.git

# Download programs

/Users/codosapiens/.pyenv/versions/2.7.18/bin/pip install networkx
/Users/codosapiens/.pyenv/versions/2.7.18/bin/pip install numpy 
# Note: I had trouble getting scipy to run in python2 so I often commented it out

# Open python2 (install if needed)
Local file: /Users/codosapiens/Desktop/projects/DRAGON/draft1/original_data
Run python2: /Users/codosapiens/.pyenv/versions/2.7.18/bin/python

Complementary exposure is combination of 2 elements: drug modules overlap disease module (proximity, z < 0) 
but not each other (distance, sAB > 0). 


# CALCLATE Z: Run proximity calculation

# Here, I think the nodes_from are going to be the drug targets and the nodes_to are going to be the disease genes 
# Question is what is the network? The entire "brain background"? 

Run python2: /Users/codosapiens/.pyenv/versions/2.7.18/bin/python

>>> from toolbox import wrappers
scipy is not installed, rank-based distance methods wont work
GenRev not found, steiner wont work
Import error: Negex. Using keyword matching instead
DIAMOnD not found and thus will not be available!
>>> file_name = "data/toy.sif"
>>> network = wrappers.get_network(file_name, only_lcc = True)    # get_network line 120: https://github.com/emreg00/toolbox/blob/master/wrappers.py
Shrinking network to its LCC 11 15
Final shape: 11 15
>>> nodes_from = ["A", "C"]
>>> nodes_to = ["B", "D", "E"]
>>> d, z, (mean, sd) = wrappers.calculate_proximity(network, nodes_from, nodes_to, min_bin_size = 2, seed=452456)
>>> print (d, z, (mean, sd))
(1.0, 1.3870748387117167, (0.671, 0.2371897974197035))

# Calculate the closest distance from target to disease genes
 wrappers.calculate_closest_distance(network, nodes_from, nodes_to, lengths=None)

# Here, I think the nodes_from are going to be the drug targets of drug A and the nodes_to are going to be the drug targets of drug B
# Again, question is what is the network? The entire "brain background"?

# CALCULATE sAB: Calculate d where dAB - (dAA + dBB) / 2.0

wrappers.get_separation(network, nodes_from, nodes_to)
0.0



# Others to run

wrappers.calculate_lcc_significance(network, list(network.nodes()))
